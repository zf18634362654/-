有关事务相关

一般事务都是交给数据库（针对单个数据库）来处理的，但是当一个事务操作两个数据库时，有一个数据库事务异常也不会让两个数据库都回滚，于是就出来了分布式事务  如下例

人为制造一个被除数为0的异常。然后对该服务对应的Controller方法发送请求。（postman）

```
@Resource
private JdbcTemplate primaryJdbcTemplate;
@Resource
private JdbcTemplate secondaryJdbcTemplate;

@Transactional
public Article saveArticle( Article article) {
    articleJDBCDAO.save(article,primaryJdbcTemplate);
    articleJDBCDAO.save(article,secondaryJdbcTemplate);
    int a = 2/0;    //人为制造一个被除数为0的异常
    return article;
}
```

secondaryJdbcTemplate的数据插入数据成功，primaryJdbcTemplate的数据插入数据失败。数据库事务不能跨连接, 当然也就不能跨数据源，更不能跨库。一旦出现跨连接的情况，也就成了分布式事务，事务就不能单纯依赖于数据库去处理。我们这一节的实现方式，是通过**![image-20191110091445553](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20191110091445553.png)**来实现。

![image-20191111190752754](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20191111190752754.png)

## 并发环境下的数据库事务

## 2.1 事务并发执行会出现的问题

我们先来看一下事务并发，数据库可能会出现的问题：

- 更新丢失（问题严重）
  当有两个并发执行的事务，更新同一行数据，那么有可能一个操作会把另一个操作的更新覆盖掉。 **（交给数据库规定 处理）**
- 脏读 （问题严重）
  一个事务读到另一个尚未提交的事务中的数据，即读到了事务的处理过程中的数据，而不是结果数据。 该数据可能会被回滚从而失效。 如果第一个事务拿着失效的数据去处理那就发生错误了。***（交给数据库规定 处理）****
- 不可重复读 （一般来说可以接受）
  不可重复读的含义：一个事务对同一行数据读了两次，却得到了不同的结果。它具体分为如下两种情况：
  虚读：在事务1两次读取同一记录的过程中，事务2对该记录进行了修改，从而事务1第二次读到了不一样的记录。
  幻读：事务1在两次查询的过程中，事务2对该表进行了插入、删除操作，从而事务1第二次查询的结果数量发生了变化。   **程序员来处理**   **乐观锁   悲观锁**

> 不可重复读 与 脏读 的区别？
> 脏读读到的是尚未提交的数据，而不可重复读读到的是已经提交的数据，只不过在两次读的过程中数据被另一个事务改过了。

## 2.3 如何解决并发过程中事务问题（事务隔离）

数据库一共有如下四种隔离级别：

- Read uncommitted 读未提交
  在该级别下，一个事务对一行数据修改的过程中，不允许另一个事务对该行数据进行修改，但允许另一个事务对该行数据读。
  因此本级别下，不会出现更新丢失，但会出现脏读、不可重复读。
- Read committed 读提交 （oracle、sqlserver默认的隔离级别）
  在该级别下，未提交的写事务不允许其他事务访问该行，因此**不会出现脏读**；但是读取数据的事务允许其他事务的访问该行数据，因此会出现不可重复读的情况。
- Repeatable read 重复读 （mysql的默认隔离级别）
  简单说就是：一个事务开始读或写数据时，不允许其他事务对该数据进行修改。在该级别下，读事务禁止写事务，但允许读事务，因此不会出现同一事务两次读到不同的数据的情况（不可重复读），且写事务禁止其他一切事务。**这个级别无法解决幻读问题**。
- Serializable 序列化
  该级别要求所有事务都必须串行执行，因此能避免一切因并发引起的问题，但效率很低。
  ![img](https://box.kancloud.cn/d1f1334fce5a9b832eafb79085333c26_844x334.png)
  隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，应该由应用程序员采用悲观锁或乐观锁来控制。

 



**分布式事务分为两种： 跨服务的分布式事务，跨库的分布式事务。** 

   

1. **跨库的分布式事务：**我在做一个服务A的时候，需要同时操作两个数据库。我们之前给大家讲的例子都是这一种，实际上总的思路就是有一个对象统一管理多个事务的提交与回滚。这种分布式事务还是在数据库层面去解决的。
2.  **跨服务分布式事务:** 也就是说我在做一个服务A的时候，需要通过网络调用多个其他服务，有可能第一个服务B成功了，第二个服务C执行失败了。这种分布式单纯的依靠数据库层面就很难解决了，一般都是通过最终一致性的方式解决。比如：通过MQ，给服务B发消息，服务B执行，然后真的做持久化操作数据入库了。给服务C发消息，服务C执行失败，这个消息就会存在MQ里面，依照一定的策略还会发给服务C，直到服务C成功为止。这样保障最终一致 

MQ  最终一致性