# 乐优商城



## 服务调用两种方式

1.RPC（Dubbo）

2.HTTP（Rest风格通过HTTP协议实现）



二者都是基于TCP的，但是RPC更快，因为RPC基于传输层     HTTP基于应用层



## Http客户端工具

- HttpClient
- OKHttp    
- URLConnection

不同的客户端API各不相同





## Spring的RestTemlate

对基于http客户端进行了封装，并且实现乐对象与json的序列化和反序列化（没有限定http的客户端类型）



## SpringCloud五大组件

## 1.Eureka

Eureka中每台机器都是peer-to-peer的，集群中的机器地位平等，各个服务可以向任何一个Eureka实例注册和发现。集群中的任何一个Eureka接收到写请求后，会自动同步给所有的Eureka实例。与Dubbo使用的一致性同步机制CP不同，Eureka使用的是AP。使用默认的配置服务上下线服务感知的时效性是非常糟糕的，可能需要几十秒，甚至是分钟级别的。

服务注册中心原理入下图所示：

![img](https://img2018.cnblogs.com/blog/1143025/201909/1143025-20190923201648834-195189012.png)

 

 

 

其中 服务A，服务B，服务C都有Eureka Client组件，这些组件负责将服务的注册信息注册到 Eureka服务中。

Eureka是一个注册中心，里面保存了一个注册表，用于记录各个服务所在的机器信息，端口号。

 

## 2.Feign

订单服务注册中心确实知道服务A、服务B、服务C在哪里了，同时也监听着哪些端口号了。

但是当他们要之间需要进行通信的时候，难道要手动写一大堆代码，让他们建立网络连接，封装他们需要传递的参数，发送请求，并对相应的数据进行处理？

如果你是基于SpringCloud对外发布一个接口，实际上是基于http协议的，对外发布的就是一个最最普通的SpringMVC接口。

Feign，通过对一个接口打上注解，他会基于这个注解标注的接口生成动态代理，然后针对Feign的动态代理去调用他的方法时，会在底层生成http协议格式的请求，

  IP：端口号/order/create？productId=1

最后针对这个地址，发起请求、解析响应。

 

 

## 3.Ribbon

如果A服务部署在两台机器上面，Feign如何知道请求哪台机器呢？ Ribbon就派上用场了

Feign底层使用的是HttpClient，先得使用Ribbon从本地的Eureka注册表的缓存里获取出对方的机器列表

然后再进行Ribbon根据 负载均衡算法 选择一台机器出来

Feign就会针对这台机器发送Http请求

 

 

## 4.Hystrix

Hystrix是一个隔离，熔断，降级的框架。

隔离：当服务A请求调用服务B，C时，请求服务B时一个线程池，请求服务C是一个线程池。相互之间互不影响

熔断：当服务A完成一项逻辑业务，需要调用服务B， 如果服务B挂掉了，每次调用到会被卡住几秒钟，会影响用户的操作体验，我们一般直接对服务B熔断，不走网络请求的那几秒钟，这个过程，就是熔断。

降级：服务B熔断了，此时服务B不能啥都不干啊，此时，就来个降级，此时需要往数据库表或日志文件中记录一条消息，说某个用户因为服务B挂掉，进行的操作没成功，并且带上参数，等到 服务B服务再次回复，你可以根据这些记录手动补上记录。

 

 

## 5.Zuul

这个组件主要负责 网络路由， 当你部署的Spring Cloud集群达到了几百个的时候，每个服务实例都有自己的名字，当你需要调用的时候，不可能基于每个服务实例的名字，一个个去调用，此时就需要一个集中的网关。

有了网关，如果前端、移动端要调用后端系统，不用管后台有多少服务实例，所有的请求只需直接走网关，网关会将请求转发给后台的所有微服务